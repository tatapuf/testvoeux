<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>L'Atelier des Particules - Cinematic Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@300;600&family=Cinzel:wght@400;700&family=Cormorant+Garamond:ital,wght@1,400;1,600&display=swap');

        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: 'Montserrat', sans-serif; user-select: none;
        }

        /* UI OVERLAY */
        #ui-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: flex-end; align-items: center;
            padding-bottom: 10vh;
            background: radial-gradient(circle at center, transparent 20%, #000000 130%);
        }

        /* TEXTES */
        .chapter-marker {
            font-family: 'Montserrat', sans-serif; font-size: 0.8rem; letter-spacing: 8px; 
            text-transform: uppercase; color: rgba(255,255,255,0.4); margin-bottom: 30px;
            opacity: 0; transform: translateY(-20px); transition: all 1.5s ease;
        }

        .narrative-text {
            font-family: 'Cormorant Garamond', serif; font-size: clamp(1.5rem, 4vw, 2.5rem);
            font-style: italic; text-align: center; color: #eee; line-height: 1.4;
            max-width: 800px; padding: 0 20px;
            text-shadow: 0 5px 30px black;
            opacity: 0; transform: translateY(30px); filter: blur(10px);
            transition: all 1.2s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .active { opacity: 1 !important; transform: translateY(0) !important; filter: blur(0) !important; }
        .highlight { color: #ffcc66; font-weight: 600; text-shadow: 0 0 20px rgba(255, 200, 50, 0.5); }

        /* ÉCRAN TITRE */
        #intro-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20;
            background: black; display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 1.5s; cursor: pointer; pointer-events: auto;
        }
        h1 {
            font-family: 'Cinzel', serif; font-size: clamp(2rem, 6vw, 5rem); letter-spacing: 15px;
            color: white; text-align: center; margin-bottom: 20px;
            text-shadow: 0 0 50px rgba(100, 150, 255, 0.5);
        }
        .start-hint {
            font-size: 0.8rem; letter-spacing: 4px; text-transform: uppercase; color: #666;
            animation: pulse 2s infinite;
        }

        @keyframes pulse { 0%, 100% { opacity: 0.4; } 50% { opacity: 1; } }

        /* PROGRESS BAR */
        #progress {
            position: absolute; bottom: 0; left: 0; height: 3px; background: linear-gradient(90deg, #000, #fff, #000);
            width: 0%; transition: width 0.5s; opacity: 0.5;
        }

        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
    </style>
</head>
<body>

    <div id="intro-screen">
        <h1>L'Atelier des Particules</h1>
        <div class="start-hint">Cliquez pour entrer dans le rêve</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-container">
        <div id="chapter-el" class="chapter-marker">PROLOGUE</div>
        <div id="text-el" class="narrative-text"></div>
    </div>
    <div id="progress"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
        // --- DONNÉES NARRATIVES COMPLÈTES ---
        const story = [
            {
                type: "intro",
                text: "La créativité n'est pas une magie.<br>C'est une danse entre trois forces invisibles.",
                shape: "cloud", // Nuage informe
                color: 0xffffff,
                camDist: 150
            },
            {
                chapter: "MOUVEMENT I : LA MATIÈRE",
                text: "Au commencement, il y a les <span class='highlight'>Idées</span>.<br>Des étincelles quantiques, rapides et chaotiques.",
                shape: "sparks", // Sphère éclatée
                color: 0xffdd55, // Or
                camDist: 120
            },
            {
                chapter: "MOUVEMENT I : LA MATIÈRE",
                text: "Puis viennent les <span class='highlight'>Émotions</span>.<br>Des nuages profonds qui colorent la pensée.",
                shape: "waves", // Ondulation
                color: 0x3366ff, // Bleu profond
                camDist: 140
            },
            {
                chapter: "MOUVEMENT I : LA MATIÈRE",
                text: "Et enfin l'<span class='highlight'>Empathie</span>.<br>C'est elle qui oriente la création vers l'autre.",
                shape: "heart_abstract", // Forme organique ronde
                color: 0xff5588, // Rose
                camDist: 100
            },
            {
                chapter: "MOUVEMENT II : LA DANSE",
                text: "Regardez le processus s'amorcer.<br>Une idée traverse une émotion et devient vivante.",
                shape: "dna", // Double hélice
                color: 0x00ccff, // Cyan
                camDist: 160
            },
            {
                chapter: "MOUVEMENT II : LA DANSE",
                text: "Les trajectoires se courbent.<br>Elles forment des constellations de sens.",
                shape: "atom", // Orbites
                color: 0xaa88ff, // Violet
                camDist: 130
            },
            {
                chapter: "MOUVEMENT III : CRISTALLISATION",
                text: "Soudain, le chaos se fige.<br>Une structure apparaît.",
                shape: "crystal_form", // Icosaèdre se formant
                color: 0xffaa00, // Orange feu
                camDist: 110
            },
            {
                chapter: "MOUVEMENT III : CRISTALLISATION",
                text: "C'est l'œuvre finale.<br>Une histoire, une musique, une solution.",
                shape: "diamond", // Diamant parfait
                color: 0xffffff, // Blanc pur éclatant
                camDist: 80
            },
            {
                chapter: "MOUVEMENT IV : HABITER",
                text: "Tu n'es pas séparé de ce monde.<br>Chaque regard que tu portes ajoute une particule.",
                shape: "tunnel", // Tunnel infini
                color: 0x44ffaa, // Vert émeraude
                camDist: 50
            },
            {
                chapter: "FIN",
                text: "Créer, c'est apprendre à danser avec le chaos.<br>L'Atelier est ouvert.",
                shape: "galaxy", // Galaxie spirale
                color: 0xffccff,
                camDist: 200
            }
        ];

        let currentStep = -1;
        let isTransitioning = false;

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.008);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.z = 200;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // POST-PROCESS (BLOOM)
        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(new THREE.RenderPass(scene, camera));
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.8, 0.05);
        composer.addPass(bloomPass);

        // --- GÉNÉRATEUR DE FORMES (MORPHING) ---
        const particleCount = 25000;
        
        function getShapePosition(type, i) {
            const ratio = i / particleCount;
            const phi = Math.acos(-1 + (2 * i) / particleCount);
            const theta = Math.sqrt(particleCount * Math.PI) * phi;
            
            switch(type) {
                case 'cloud': 
                    return {
                        x: (Math.random()-0.5)*300, 
                        y: (Math.random()-0.5)*150, 
                        z: (Math.random()-0.5)*150
                    };
                case 'sparks': 
                    // Sphère éclatée
                    const rSpark = 100 * Math.random();
                    return {
                        x: rSpark * Math.sin(phi) * Math.cos(theta),
                        y: rSpark * Math.sin(phi) * Math.sin(theta),
                        z: rSpark * Math.cos(phi)
                    };
                case 'waves':
                    const wX = (ratio - 0.5) * 300;
                    const wY = Math.sin(wX * 0.05 + i * 0.01) * 30;
                    const wZ = Math.cos(wX * 0.05) * 50 + (Math.random()-0.5)*40;
                    return {x: wX, y: wY, z: wZ};
                case 'heart_abstract':
                    // Forme organique bulbeuse
                    const hR = 40 + Math.sin(theta*5)*5;
                    return {
                        x: hR * Math.sin(phi) * Math.cos(theta),
                        y: hR * Math.sin(phi) * Math.sin(theta),
                        z: hR * Math.cos(phi)
                    };
                case 'dna':
                    const dAngle = ratio * Math.PI * 20;
                    const dRad = 30;
                    const dY = (ratio - 0.5) * 200;
                    const dStrand = (i % 2 === 0) ? 0 : Math.PI;
                    return {
                        x: Math.cos(dAngle + dStrand) * dRad,
                        y: dY,
                        z: Math.sin(dAngle + dStrand) * dRad
                    };
                case 'atom':
                    // Anneaux orbitaux
                    const orbit = i % 3;
                    const aAngle = ratio * Math.PI * 2;
                    const aRad = 60 + Math.random()*10;
                    let ax=0, ay=0, az=0;
                    if(orbit===0) { ax = Math.cos(aAngle)*aRad; ay = Math.sin(aAngle)*aRad; }
                    if(orbit===1) { ax = Math.cos(aAngle)*aRad; az = Math.sin(aAngle)*aRad; }
                    if(orbit===2) { ay = Math.cos(aAngle)*aRad; az = Math.sin(aAngle)*aRad; }
                    return {x: ax, y: ay, z: az};
                case 'crystal_form':
                    // Cube en formation
                    const cSize = 50 * Math.random();
                    return {
                        x: (Math.random()>0.5?1:-1) * cSize,
                        y: (Math.random()>0.5?1:-1) * cSize,
                        z: (Math.random()>0.5?1:-1) * cSize
                    };
                case 'diamond':
                    // Octaèdre net
                    const dim = 50;
                    let dx = (Math.random()-0.5)*dim*2;
                    let dy = (Math.random()-0.5)*dim*2;
                    let dz = (Math.random()-0.5)*dim*2;
                    // Projection sur les faces
                    if(Math.abs(dx)+Math.abs(dy)+Math.abs(dz) > dim) {
                        const s = dim / (Math.abs(dx)+Math.abs(dy)+Math.abs(dz));
                        dx*=s; dy*=s; dz*=s;
                    }
                    return {x: dx, y: dy, z: dz};
                case 'tunnel':
                    const tAngle = ratio * Math.PI * 100;
                    const tRad = 40 + Math.random() * 50;
                    const tZ = (ratio * 500) - 250;
                    return {
                        x: Math.cos(tAngle) * tRad,
                        y: Math.sin(tAngle) * tRad,
                        z: tZ
                    };
                case 'galaxy':
                    const gArm = (i % 5) * (2*Math.PI/5);
                    const gDist = Math.random();
                    const gSpin = gDist * 10;
                    const gR = gDist * 150;
                    return {
                        x: Math.cos(gSpin + gArm) * gR,
                        y: (Math.random()-0.5) * 20 * (1-gDist),
                        z: Math.sin(gSpin + gArm) * gR
                    };
                default:
                    return {x:0, y:0, z:0};
            }
        }

        // --- PARTICULES & SHADER ---
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(particleCount*3); // Position actuelle
        const target = new Float32Array(particleCount*3); // Position cible
        const randoms = new Float32Array(particleCount); // Variation bruit
        
        for(let i=0; i<particleCount; i++){
            const p = getShapePosition('cloud', i);
            pos[i*3] = p.x; pos[i*3+1] = p.y; pos[i*3+2] = p.z;
            target[i*3] = p.x; target[i*3+1] = p.y; target[i*3+2] = p.z;
            randoms[i] = Math.random();
        }
        
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        geo.setAttribute('target', new THREE.BufferAttribute(target, 3));
        geo.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));

        // Texture éclatante
        function createGlow() {
            const c = document.createElement('canvas'); c.width=64; c.height=64;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(32,32,0,32,32,32);
            g.addColorStop(0,'rgba(255,255,255,1)');
            g.addColorStop(0.3,'rgba(255,255,255,0.5)');
            g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(c);
        }

        const mat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(0xffffff) },
                uTexture: { value: createGlow() },
                uRatio: { value: window.devicePixelRatio },
                uProgress: { value: 0 }, // Pour le morphing
                uChaos: { value: 0 } // Pour l'explosion de transition
            },
            vertexShader: `
                uniform float uTime;
                uniform float uRatio;
                uniform float uChaos;
                attribute vec3 target;
                attribute float aRandom;
                varying float vAlpha;

                // Noise
                float hash(float n) { return fract(sin(n) * 43758.5453123); }
                
                void main() {
                    vec3 p = position; // Position interpolée par JS
                    
                    // Animation vivante constante
                    float noise = sin(uTime * 2.0 + aRandom * 10.0);
                    p += normalize(p) * noise * 2.0;

                    // Chaos de transition (Explosion)
                    if (uChaos > 0.01) {
                        vec3 dir = normalize(p);
                        p += dir * uChaos * 100.0 * (0.5 + aRandom);
                    }

                    vec4 mv = modelViewMatrix * vec4(p, 1.0);
                    gl_Position = projectionMatrix * mv;

                    // Taille
                    float size = (30.0 + aRandom * 50.0);
                    gl_PointSize = (size * uRatio) / -mv.z;
                    
                    vAlpha = smoothstep(300.0, 50.0, -mv.z);
                }
            `,
            fragmentShader: `
                uniform vec3 uColor;
                uniform sampler2D uTexture;
                varying float vAlpha;
                void main() {
                    vec4 tex = texture2D(uTexture, gl_PointCoord);
                    // Couleurs super brillantes (HDR)
                    gl_FragColor = vec4(uColor * 2.0, tex.a * vAlpha);
                }
            `,
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });
        
        const particles = new THREE.Points(geo, mat);
        scene.add(particles);

        // --- MOTEUR DE TRANSITION ---
        function goToStep(index) {
            if(index >= story.length) index = 0; // Boucle
            currentStep = index;
            isTransitioning = true;
            
            const data = story[index];
            const pArr = geo.attributes.position.array;
            const tArr = geo.attributes.target.array;

            // 1. Calcul des nouvelles positions cibles
            for(let i=0; i<particleCount; i++) {
                const pos = getShapePosition(data.shape, i);
                tArr[i*3] = pos.x; tArr[i*3+1] = pos.y; tArr[i*3+2] = pos.z;
            }
            geo.attributes.target.needsUpdate = true;

            // 2. Timeline GSAP Spectaculaire
            const tl = gsap.timeline({ onComplete: () => isTransitioning = false });

            // a. Chaos/Explosion
            tl.to(mat.uniforms.uChaos, { value: 1, duration: 0.8, ease: "power2.in" });
            
            // b. Changement de couleur et de caméra PENDANT le chaos
            tl.add(() => {
                gsap.to(mat.uniforms.uColor.value, { 
                    r: new THREE.Color(data.color).r, 
                    g: new THREE.Color(data.color).g, 
                    b: new THREE.Color(data.color).b, 
                    duration: 1 
                });
                
                // On met à jour les positions réelles instantanément au sommet du chaos
                // pour que le shader interpolate vers la bonne forme en revenant
                // Note: Ici on fait un morphing custom en update loop, donc juste on reset
            });

            // c. Recomposition (Implosion vers la nouvelle forme)
            tl.to(mat.uniforms.uChaos, { value: 0, duration: 1.5, ease: "elastic.out(1, 0.5)" });

            // Caméra fluide
            gsap.to(camera.position, { z: data.camDist, duration: 3, ease: "power2.inOut" });

            // Textes
            updateUI(data);
            
            // Barre de progression
            document.getElementById('progress').style.width = ((index+1) / story.length * 100) + "%";
        }

        function updateUI(data) {
            const chap = document.getElementById('chapter-el');
            const txt = document.getElementById('text-el');
            
            // Fade out
            chap.classList.remove('active');
            txt.classList.remove('active');
            
            setTimeout(() => {
                chap.innerText = data.chapter || "";
                txt.innerHTML = data.text;
                // Fade in
                if(data.chapter) chap.classList.add('active');
                txt.classList.add('active');
            }, 800);
        }

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const elapsed = clock.getElapsedTime();
            mat.uniforms.uTime.value = elapsed;

            // MORPHING MANUEL (Plus organique que le shader seul)
            // On déplace chaque particule vers sa cible 'target'
            const positions = geo.attributes.position.array;
            const targets = geo.attributes.target.array;
            // Vitesse variable selon si on est en chaos ou pas
            const lerpSpeed = 3.0 * dt; 

            for(let i=0; i<particleCount; i++) {
                const ix = i*3;
                const iy = ix+1;
                const iz = ix+2;
                
                positions[ix] += (targets[ix] - positions[ix]) * lerpSpeed;
                positions[iy] += (targets[iy] - positions[iy]) * lerpSpeed;
                positions[iz] += (targets[iz] - positions[iz]) * lerpSpeed;
            }
            geo.attributes.position.needsUpdate = true;

            // Caméra Drift (Mouvement perpétuel)
            camera.rotation.z = Math.sin(elapsed * 0.05) * 0.1;
            camera.position.x = Math.sin(elapsed * 0.1) * 20;
            camera.position.y = Math.cos(elapsed * 0.15) * 10;
            camera.lookAt(0,0,0);

            // Rendu Bloom
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            mat.uniforms.uRatio.value = renderer.getPixelRatio();
        });

        // --- INTERACTION ---
        function next() {
            if(!isTransitioning) goToStep(currentStep + 1);
        }

        document.getElementById('intro-screen').addEventListener('click', () => {
            document.getElementById('intro-screen').style.opacity = 0;
            setTimeout(() => {
                document.getElementById('intro-screen').style.display = 'none';
                next(); // Lancer le premier chapitre
            }, 1500);
        });

        window.addEventListener('keydown', (e) => {
            if(e.code === 'Space' || e.code === 'ArrowRight') next();
        });
        
        window.addEventListener('click', (e) => {
            if(document.getElementById('intro-screen').style.display === 'none') next();
        });

        animate();

    </script>
</body>
</html>
