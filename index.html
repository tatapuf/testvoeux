<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>L’Atelier - UNIVERSAL EDITION</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Montserrat:wght@300;400;600&display=swap');

    body { margin: 0; overflow: hidden; background: #000; font-family: 'Montserrat', sans-serif; color: white; -webkit-tap-highlight-color: transparent; }
    
    #c { position: absolute; inset: 0; z-index: 1; }

    /* UI OVERLAY */
    #intro {
      position: absolute; inset: 0; z-index: 50;
      background: radial-gradient(circle, #1a1a2e 0%, #000 100%);
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      transition: opacity 1s; cursor: pointer;
    }
    
    h1 {
      font-family: 'Cinzel', serif; font-size: clamp(2rem, 8vw, 4rem); text-align: center;
      text-transform: uppercase; letter-spacing: 0.1em; margin: 0 0 20px 0;
      text-shadow: 0 0 30px rgba(0,150,255,0.5);
    }
    
    .tap-hint {
      padding: 15px 30px; border: 1px solid rgba(255,255,255,0.3); border-radius: 50px;
      text-transform: uppercase; letter-spacing: 3px; font-size: 0.8rem;
      animation: pulse 1.5s infinite; background: rgba(0,0,0,0.3);
    }
    @keyframes pulse { 0%{opacity:0.5} 50%{opacity:1} 100%{opacity:0.5} }

    /* UI NARRATION */
    #ui-layer {
      position: absolute; bottom: 0; left: 0; width: 100%; height: 40%; z-index: 10;
      pointer-events: none; display: flex; flex-direction: column; justify-content: flex-end; align-items: center;
      padding-bottom: 40px; opacity: 0; transition: opacity 1.5s;
      background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
    }
    
    .chapter { font-family: 'Cinzel', serif; color: #888; font-size: 0.7rem; letter-spacing: 4px; margin-bottom: 10px; }
    
    .text {
      font-family: 'Cinzel', serif; font-size: clamp(1.2rem, 5vw, 2rem); text-align: center;
      max-width: 90%; line-height: 1.3; text-shadow: 0 4px 20px black;
    }
    .hl { color: #ffaa00; text-shadow: 0 0 20px #ffaa00; }

    /* DEBUGGER VISUEL */
    #error-log {
      position: absolute; top: 0; left: 0; width: 100%; background: rgba(50,0,0,0.9);
      color: #ffaaaa; padding: 10px; font-family: monospace; font-size: 10px;
      z-index: 100; display: none; pointer-events: none; white-space: pre-wrap;
    }
  </style>
</head>
<body>

  <div id="error-log"></div>

  <div id="intro">
    <h1>L'ATELIER<br>INFINI</h1>
    <div class="tap-hint">Touchez l'écran</div>
    <div id="loading-state" style="margin-top:10px; font-size:10px; color:#666">Chargement des librairies...</div>
  </div>

  <div id="ui-layer">
    <div id="chap" class="chapter"></div>
    <div id="txt" class="text"></div>
  </div>

  <canvas id="c"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  
  <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/misc/GPUComputationRenderer.js"></script>

  <script>
    // --- GESTION DES ERREURS ---
    window.onerror = function(msg, source, lineno, colno, error) {
        document.getElementById('error-log').style.display = 'block';
        document.getElementById('error-log').innerText += "ERREUR: " + msg + "\n";
    };

    const loadingState = document.getElementById('loading-state');
    loadingState.innerText = "Initialisation Moteur...";

    // --- CONFIGURATION ---
    const SETTINGS = {
        SIZE: 128, // 16384 particules (Fluide sur iPhone)
        BLOOM: 1.5
    };
    const PARTICLES = SETTINGS.SIZE * SETTINGS.SIZE;

    // --- SCENARIO ---
    const story = [
        { chap: "I. LA MATIÈRE", txt: "Une idée est une <span class='hl'>étincelle</span>.", color: new THREE.Color(1.0, 0.6, 0.1), shape: "chaos" },
        { chap: "II. L'ÉMOTION", txt: "C'est une <span class='hl' style='color:#00aaff'>vague</span> qui emporte tout.", color: new THREE.Color(0.1, 0.5, 1.0), shape: "wave" },
        { chap: "III. LA CONNEXION", txt: "L'empathie tisse des <span class='hl' style='color:#ff0055'>liens</span>.", color: new THREE.Color(1.0, 0.1, 0.5), shape: "dna" },
        { chap: "IV. L'ŒUVRE", txt: "Le chaos devient <span class='hl' style='color:#00ff88'>structure</span>.", color: new THREE.Color(0.2, 1.0, 0.6), shape: "sphere" },
        { chap: "V. INFINI", txt: "Tu es le centre de ce monde.", color: new THREE.Color(0.8, 0.5, 1.0), shape: "galaxy" }
    ];
    let currentStep = 0;

    // --- THREE.JS SETUP ---
    const canvas = document.querySelector('#c');
    const renderer = new THREE.WebGLRenderer({canvas, powerPreference: "high-performance", antialias: false});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.005);
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 120;

    // --- GPGPU (PHYSICS) ---
    let gpuCompute, velVar, posVar;
    
    function initGPGPU() {
        gpuCompute = new THREE.GPUComputationRenderer(SETTINGS.SIZE, SETTINGS.SIZE, renderer);
        
        // Si pas de float texture (iPhone parfois), fallback
        if (!renderer.capabilities.isWebGL2) {
            gpuCompute.setDataType(THREE.HalfFloatType);
        }

        const dtPos = gpuCompute.createTexture();
        const dtVel = gpuCompute.createTexture();
        const dtTarget = gpuCompute.createTexture();

        fillTextures(dtPos, dtVel, dtTarget);

        // SHADER VELOCITY (MOUVEMENT)
        const velShader = `
            uniform float uTime;
            uniform sampler2D texturePosition;
            uniform sampler2D textureTarget;
            
            // Noise simple
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) { const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0); vec3 i = floor(v + dot(v, C.yyy)); vec3 x0 = v - i + dot(i, C.xxx); vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g; vec3 i1 = min(g.xyz, l.zxy); vec3 i2 = max(g.xyz, l.zxy); vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy; i = mod289(i); vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0)); float n_ = 0.142857142857; vec3 ns = n_ * D.wyz - D.xzx; vec4 j = p - 49.0 * floor(p * ns.z * ns.z); vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_); vec4 x = x_ *ns.x + ns.yyyy; vec4 y = y_ *ns.x + ns.yyyy; vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4(x.xy, y.xy); vec4 b1 = vec4(x.zw, y.zw); vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0; vec4 sh = -step(h, vec4(0.0)); vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww; vec3 p0 = vec3(a0.xy, h.x); vec3 p1 = vec3(a0.zw, h.y); vec3 p2 = vec3(a1.xy, h.z); vec3 p3 = vec3(a1.zw, h.w); vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3))); p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w; vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0); m = m * m; return 42.0 * dot(m*m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3))); }
            
            void main() {
                vec2 uv = gl_FragCoord.xy / resolution.xy;
                vec3 pos = texture2D(texturePosition, uv).xyz;
                vec3 vel = texture2D(textureVelocity, uv).xyz;
                vec3 tgt = texture2D(textureTarget, uv).xyz;

                // Attraction vers la cible
                vec3 force = (tgt - pos) * 0.02; // Force d'attraction
                
                // Turbulence (Curl Noise)
                float n = snoise(pos * 0.02 + uTime * 0.5);
                vec3 noiseVec = vec3(n, snoise(pos*0.02 + vec3(10.0)), snoise(pos*0.02 + vec3(20.0)));
                
                vel += force;
                vel += noiseVec * 0.05; // Turbulence
                vel *= 0.96; // Friction

                gl_FragColor = vec4(vel, 1.0);
            }
        `;

        const posShader = `
            uniform sampler2D textureVelocity;
            void main() {
                vec2 uv = gl_FragCoord.xy / resolution.xy;
                vec3 pos = texture2D(texturePosition, uv).xyz;
                vec3 vel = texture2D(textureVelocity, uv).xyz;
                pos += vel;
                gl_FragColor = vec4(pos, 1.0);
            }
        `;

        velVar = gpuCompute.addVariable("textureVelocity", velShader, dtVel);
        posVar = gpuCompute.addVariable("texturePosition", posShader, dtPos);

        gpuCompute.setVariableDependencies(velVar, [velVar, posVar]);
        gpuCompute.setVariableDependencies(posVar, [velVar]); // Dépend de la vélocité

        // Uniforms custom
        velVar.material.uniforms.uTime = { value: 0 };
        velVar.material.uniforms.textureTarget = { value: dtTarget };

        // C'est vital de stocker la référence à la texture target pour la mettre à jour
        window.targetUniform = velVar.material.uniforms.textureTarget;
        window.targetTexture = dtTarget;

        const error = gpuCompute.init();
        if (error !== null) console.error(error);
    }

    function fillTextures(pos, vel, target) {
        const pArr = pos.image.data;
        const vArr = vel.image.data;
        const tArr = target.image.data;

        for (let k = 0; k < pArr.length; k += 4) {
            // Random start
            const x = (Math.random()-0.5)*100;
            const y = (Math.random()-0.5)*100;
            const z = (Math.random()-0.5)*100;
            
            pArr[k] = x; pArr[k+1] = y; pArr[k+2] = z; pArr[k+3] = 1;
            tArr[k] = x; tArr[k+1] = y; tArr[k+2] = z; tArr[k+3] = 1;
            vArr[k] = 0; vArr[k+1] = 0; vArr[k+2] = 0; vArr[k+3] = 1;
        }
    }

    // --- VISUALISATION ---
    let particleMat;
    function initVisuals() {
        // Texture brillante générée
        const canvas = document.createElement('canvas'); canvas.width=64; canvas.height=64;
        const ctx = canvas.getContext('2d');
        const g = ctx.createRadialGradient(32,32,0,32,32,32);
        g.addColorStop(0,'white'); g.addColorStop(0.4,'rgba(255,255,255,0.2)'); g.addColorStop(1,'transparent');
        ctx.fillStyle=g; ctx.fillRect(0,0,64,64);
        const tex = new THREE.CanvasTexture(canvas);

        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(PARTICLES * 3);
        const uv = new Float32Array(PARTICLES * 2);
        
        for (let i=0; i<SETTINGS.SIZE; i++) {
            for (let j=0; j<SETTINGS.SIZE; j++) {
                const k = (i*SETTINGS.SIZE + j);
                pos[k*3] = 0; 
                uv[k*2] = j/(SETTINGS.SIZE-1); 
                uv[k*2+1] = i/(SETTINGS.SIZE-1);
            }
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        geo.setAttribute('uv', new THREE.BufferAttribute(uv, 2));

        particleMat = new THREE.ShaderMaterial({
            uniforms: {
                tPos: { value: null },
                uColor: { value: story[0].color },
                uTex: { value: tex }
            },
            vertexShader: `
                uniform sampler2D tPos;
                varying float vAlpha;
                void main() {
                    vec3 pos = texture2D(tPos, uv).xyz;
                    vec4 mv = modelViewMatrix * vec4(pos, 1.0);
                    gl_Position = projectionMatrix * mv;
                    gl_PointSize = 200.0 / -mv.z; // GROS POINTS
                    vAlpha = smoothstep(500.0, 100.0, -mv.z);
                }
            `,
            fragmentShader: `
                uniform vec3 uColor;
                uniform sampler2D uTex;
                varying float vAlpha;
                void main() {
                    vec4 t = texture2D(uTex, gl_PointCoord);
                    gl_FragColor = vec4(uColor, t.a * vAlpha);
                }
            `,
            transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
        });

        const points = new THREE.Points(geo, particleMat);
        scene.add(points);
    }

    // --- POST-PROCESSING ---
    const composer = new THREE.EffectComposer(renderer);
    composer.addPass(new THREE.RenderPass(scene, camera));
    const bloom = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.8, 0.1);
    composer.addPass(bloom);

    // --- LOGIQUE FORMES ---
    function updateShape(name) {
        const data = window.targetTexture.image.data;
        const N = PARTICLES;
        
        for(let i=0; i<N; i++) {
            const k = i*4;
            const u = i/N;
            let x=0, y=0, z=0;

            if(name === "chaos") {
                const r = 100 * Math.cbrt(Math.random());
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
            } else if(name === "wave") {
                x = (u-0.5)*300;
                z = (Math.random()-0.5)*100;
                y = Math.sin(x*0.05)*30 + Math.cos(z*0.1)*10;
            } else if(name === "dna") {
                const angle = u * Math.PI * 20;
                const r = 30;
                x = Math.cos(angle)*r;
                z = Math.sin(angle)*r;
                y = (u-0.5)*300;
                if(i%2===0) {x+=10;} // Séparation
            } else if(name === "sphere") {
                const r = 60;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
            } else { // Galaxy
                const r = u * 150;
                const angle = u * 10;
                x = Math.cos(angle)*r;
                z = Math.sin(angle)*r;
                y = (Math.random()-0.5)*10;
            }
            data[k]=x; data[k+1]=y; data[k+2]=z;
        }
        window.targetTexture.needsUpdate = true;
    }

    // --- NAVIGATION ---
    function next() {
        currentStep = (currentStep + 1) % story.length;
        const s = story[currentStep];
        
        // Update Forme
        updateShape(s.shape);
        
        // Update Texte
        const chap = document.getElementById('chap');
        const txt = document.getElementById('txt');
        chap.style.opacity = 0; txt.style.opacity = 0;
        
        setTimeout(() => {
            chap.innerText = s.chap;
            txt.innerHTML = s.txt;
            chap.style.opacity = 1; txt.style.opacity = 1;
            
            // Couleur avec GSAP
            gsap.to(particleMat.uniforms.uColor.value, {
                r: s.color.r, g: s.color.g, b: s.color.b, duration: 1
            });
        }, 500);
    }

    // --- ANIMATION LOOP ---
    const clock = new THREE.Clock();
    
    function animate() {
        requestAnimationFrame(animate);
        const t = clock.getElapsedTime();

        // GPGPU Step
        velVar.material.uniforms.uTime.value = t;
        gpuCompute.compute();
        
        // Update Visuals
        particleMat.uniforms.tPos.value = gpuCompute.getCurrentRenderTarget(posVar).texture;

        // Camera Orbit
        camera.position.x = Math.sin(t*0.1) * 120;
        camera.position.z = Math.cos(t*0.1) * 120;
        camera.lookAt(0,0,0);

        composer.render();
    }

    // --- LANCEMENT ---
    const intro = document.getElementById('intro');
    let started = false;

    document.addEventListener('click', () => {
        if(!started) {
            started = true;
            loadingState.innerText = "Lancement...";
            
            // Init en différé pour éviter freeze UI
            setTimeout(() => {
                initGPGPU();
                initVisuals();
                updateShape(story[0].shape);
                animate(); // Start loop
                
                // Fade out intro
                intro.style.opacity = 0;
                setTimeout(() => {
                    intro.style.display = 'none';
                    document.getElementById('ui-layer').style.opacity = 1;
                    next(); // Chapitre 1
                }, 1000);
            }, 100);
        } else {
            next();
        }
    });

    // Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    });

  </script>
</body>
</html>
