<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>L'ATELIER - QUANTUM GPGPU EDITION</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Montserrat:wght@300;500&display=swap');

        body { 
            margin: 0; overflow: hidden; background-color: #010103; 
            font-family: 'Montserrat', sans-serif;
        }

        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* UI HAUT DE GAMME */
        #ui-layer {
            position: absolute; top:0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: radial-gradient(circle at center, transparent 30%, rgba(0,0,0,0.8) 100%);
        }

        .chapter-marker {
            font-family: 'Cinzel', serif; color: rgba(255,255,255,0.4); letter-spacing: 10px; font-size: 0.8rem;
            text-transform: uppercase; margin-bottom: 20px;
            opacity: 0; transform: translateY(-20px); transition: all 2s cubic-bezier(0.19, 1, 0.22, 1);
        }

        .narrative-text {
            font-family: 'Cinzel', serif; color: #fff; font-size: clamp(1.8rem, 5vw, 3.5rem);
            text-align: center; max-width: 90%; line-height: 1.2;
            text-shadow: 0 0 40px rgba(255, 255, 255, 0.5);
            opacity: 0; transform: scale(0.95); filter: blur(20px);
            transition: all 2.5s cubic-bezier(0.19, 1, 0.22, 1);
        }

        .narrative-text span {
            display: block; font-size: 0.5em; letter-spacing: 5px; color: rgba(255,255,255,0.6); margin-top: 20px; font-family: 'Montserrat'; text-transform: uppercase;
        }

        .visible { opacity: 1 !important; transform: translateY(0) scale(1) !important; filter: blur(0) !important; }
        .highlight { color: #ffaa00; text-shadow: 0 0 50px #ffaa00, 0 0 100px #ffaa00; }

        /* ECRAN TITRE */
        #intro-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 50;
            background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 1.5s ease-in-out; cursor: pointer; pointer-events: auto;
        }
        h1 {
            font-family: 'Cinzel', serif; font-size: clamp(2.5rem, 8vw, 6rem); color: white;
            text-align: center; letter-spacing: 5px;
            background: linear-gradient(45deg, #ffffff, #00aaff, #ff0055);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 30px rgba(255,255,255,0.3));
        }
        .subtitle { color: #666; letter-spacing: 5px; text-transform: uppercase; margin-top: 20px; font-size: 0.8rem; }
        .loading { color: #333; margin-top: 40px; font-family: monospace; }

    </style>
</head>
<body>

    <div id="intro-screen">
        <h1>L'ATELIER<br>QUANTUM</h1>
        <div class="subtitle">Expérience GPGPU Fluide</div>
        <div class="loading" id="loading-text">Initialisation du moteur physique GPU...</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="chap-el" class="chapter-marker"></div>
        <div id="text-el" class="narrative-text"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/misc/GPUComputationRenderer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/FilmShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/RGBShiftShader.js"></script>

    <script>
        // --- CONFIGURATION "ULTRA" ---
        // La taille de la texture GPGPU détermine le nombre de particules.
        // 256x256 = 65 536 particules simulées physiquement.
        const WIDTH = 256; 
        const PARTICLES = WIDTH * WIDTH;

        // --- SCÉNARIO & DONNÉES CIBLES ---
        const story = [
            { t: "I. LA GENÈSE", s: "Une étincelle dans le néant quantique.<span>Le Chaos Originel</span>", shape: "sphere_chaos", color: new THREE.Color(1.0, 0.8, 0.5) },
            { t: "II. LE FLUX", s: "Les émotions deviennent liquides.<span>Océan d'Énergie</span>", shape: "wave_plane", color: new THREE.Color(0.1, 0.5, 1.5) },
            { t: "III. L'HELICE", s: "Le code de la vie se dessine.<span>Structure Organique</span>", shape: "dna_helix", color: new THREE.Color(0.2, 1.2, 0.5) },
            { t: "IV. L'ATTRACTEUR", s: "Le chaos trouve son ordre caché.<span>Attracteur Étrange</span>", shape: "lorenz", color: new THREE.Color(1.2, 0.2, 0.8) },
            { t: "V. L'ŒUVRE", s: "La forme parfaite émerge.<span>Cristallisation</span>", shape: "torus_knot", color: new THREE.Color(1.5, 1.5, 1.5) }
        ];
        let currentStep = -1;

        // --- MOTEUR THREE.JS ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 10, 3000);
        camera.position.z = 500;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- LE CŒUR DU SYSTÈME : GPGPU COMPUTATION ---
        let gpuCompute;
        let positionVariable;
        let positionUniforms;
        let targetTexture;

        function initGPGPU() {
            gpuCompute = new THREE.GPUComputationRenderer(WIDTH, WIDTH, renderer);

            if ( renderer.capabilities.isWebGL2 === false ) {
                gpuCompute.setDataType( THREE.HalfFloatType );
            }

            const dtPosition = gpuCompute.createTexture();
            const dtTarget = gpuCompute.createTexture();
            fillTextures(dtPosition, dtTarget); // Remplir avec des données initiales

            targetTexture = dtTarget;

            // SHADER DE SIMULATION PHYSIQUE (C'est ici que la magie opère)
            const positionShader = `
                uniform float time;
                uniform float speed;
                uniform float explosion;
                uniform sampler2D textureTarget;

                // --- CURL NOISE FUNCTION (La clé du mouvement fluide) ---
                // (Code mathématique complexe simplifié pour la démo)
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                float snoise(vec3 v) { const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0); vec3 i = floor(v + dot(v, C.yyy)); vec3 x0 = v - i + dot(i, C.xxx); vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g; vec3 i1 = min(g.xyz, l.zxy); vec3 i2 = max(g.xyz, l.zxy); vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy; i = mod289(i); vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0)); float n_ = 0.142857142857; vec3 ns = n_ * D.wyz - D.xzx; vec4 j = p - 49.0 * floor(p * ns.z * ns.z); vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_); vec4 x = x_ *ns.x + ns.yyyy; vec4 y = y_ *ns.x + ns.yyyy; vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4(x.xy, y.xy); vec4 b1 = vec4(x.zw, y.zw); vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0; vec4 sh = -step(h, vec4(0.0)); vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww; vec3 p0 = vec3(a0.xy, h.x); vec3 p1 = vec3(a0.zw, h.y); vec3 p2 = vec3(a1.xy, h.z); vec3 p3 = vec3(a1.zw, h.w); vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3))); p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w; vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0); m = m * m; return 42.0 * dot(m*m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3))); }
                vec3 curl(vec3 p) { const float e = 0.1; vec3 dx = vec3(e, 0.0, 0.0); vec3 dy = vec3(0.0, e, 0.0); vec3 dz = vec3(0.0, 0.0, e); vec3 p_x0 = snoise(p - dx) * vec3(1.0, 0.0, 0.0); vec3 p_x1 = snoise(p + dx) * vec3(1.0, 0.0, 0.0); vec3 p_y0 = snoise(p - dy) * vec3(0.0, 1.0, 0.0); vec3 p_y1 = snoise(p + dy) * vec3(0.0, 1.0, 0.0); vec3 p_z0 = snoise(p - dz) * vec3(0.0, 0.0, 1.0); vec3 p_z1 = snoise(p + dz) * vec3(0.0, 0.0, 1.0); float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y; float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z; float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x; return normalize(vec3(x, y, z)); }

                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                    vec4 tmpPos = texture2D(texturePosition, uv);
                    vec3 pos = tmpPos.xyz;
                    vec3 target = texture2D(textureTarget, uv).xyz;

                    // 1. Force d'attraction vers la cible
                    vec3 attraction = (target - pos) * speed * 0.05;
                    
                    // 2. Force de turbulence (Curl Noise) pour le mouvement fluide
                    float noiseScale = 0.005;
                    vec3 turbulence = curl(pos * noiseScale + time * 0.2) * 4.0 * (1.0 - speed*0.8); // Plus de turbulence quand c'est lent

                    // 3. Force d'explosion (transition)
                    vec3 explode = normalize(pos) * explosion * 100.0;

                    // Intégration
                    pos += attraction + turbulence + explode;

                    gl_FragColor = vec4(pos, 1.0);
                }
            `;

            positionVariable = gpuCompute.addVariable("texturePosition", positionShader, dtPosition);
            gpuCompute.setVariableDependencies(positionVariable, [positionVariable]);

            positionUniforms = positionVariable.material.uniforms;
            positionUniforms["time"] = { value: 0.0 };
            positionUniforms["speed"] = { value: 0.5 };
            positionUniforms["explosion"] = { value: 0.0 };
            positionUniforms["textureTarget"] = { value: dtTarget };

            const error = gpuCompute.init();
            if (error !== null) console.error(error);
        }

        // Initialisation des positions
        function fillTextures(texturePosition, textureTarget) {
            const posArray = texturePosition.image.data;
            const targetArray = textureTarget.image.data;
            for (let k = 0, kl = posArray.length; k < kl; k += 4) {
                // Départ : sphère aléatoire
                const r = 300 * Math.cbrt(Math.random());
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                posArray[k + 0] = r * Math.sin(phi) * Math.cos(theta);
                posArray[k + 1] = r * Math.sin(phi) * Math.sin(theta);
                posArray[k + 2] = r * Math.cos(phi);
                posArray[k + 3] = 1.0;
                // Target initiale identique
                targetArray[k+0] = posArray[k+0]; targetArray[k+1] = posArray[k+1]; targetArray[k+2] = posArray[k+2]; targetArray[k+3] = 1.0;
            }
        }

        // --- VISUALISATION DES PARTICULES ---
        let particleMaterial;
        function initParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLES * 3);
            const uvs = new Float32Array(PARTICLES * 2); // Pour lire la texture GPGPU

            for (let i = 0; i < WIDTH; i++) {
                for (let j = 0; j < WIDTH; j++) {
                    const k = i * WIDTH + j;
                    positions[k * 3 + 0] = 0; positions[k * 3 + 1] = 0; positions[k * 3 + 2] = 0;
                    uvs[k * 2 + 0] = j / (WIDTH - 1);
                    uvs[k * 2 + 1] = i / (WIDTH - 1);
                }
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

            // SHADER DE RENDU VISUEL
            particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    texturePosition: { value: null }, // Sera mis à jour par le GPGPU
                    uColor: { value: new THREE.Color(1,1,1) },
                    uRatio: { value: renderer.getPixelRatio() }
                },
                vertexShader: `
                    uniform sampler2D texturePosition;
                    uniform float uRatio;
                    varying float vDist;
                    void main() {
                        // On lit la position calculée par le GPGPU
                        vec4 posTemp = texture2D(texturePosition, uv);
                        vec3 pos = posTemp.xyz;
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        
                        // Taille dynamique selon la profondeur
                        vDist = -mvPosition.z;
                        gl_PointSize = (80.0 * uRatio) / vDist; 
                    }
                `,
                fragmentShader: `
                    uniform vec3 uColor;
                    varying float vDist;
                    void main() {
                        // Création d'un point lumineux procédural doux
                        vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                        float r = dot(cxy, cxy);
                        float delta = fwidth(r);
                        float alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
                        // Cœur brillant, bord doux
                        float glow = exp(-r*4.0); 
                        
                        // Fade out distance
                        float distAlpha = smoothstep(1000.0, 200.0, vDist);

                        gl_FragColor = vec4(uColor * glow * 2.0, alpha * distAlpha);
                    }
                `,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });

            const particles = new THREE.Points(geometry, particleMaterial);
            scene.add(particles);
        }

        // --- POST-PROCESSING CINÉMA ---
        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(new THREE.RenderPass(scene, camera));

        // 1. BLOOM HDR ULTRA-QUALITÉ
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.5, 0.8, 0.1);
        composer.addPass(bloomPass);

        // 2. ABERRATION CHROMATIQUE (Effet lentille)
        const rgbShift = new THREE.ShaderPass(THREE.RGBShiftShader);
        rgbShift.uniforms['amount'].value = 0.003;
        composer.addPass(rgbShift);

        // 3. GRAIN FILM (Texture)
        const filmPass = new THREE.ShaderPass(THREE.FilmShader);
        filmPass.uniforms['nIntensity'].value = 0.3; // Intensité du bruit
        filmPass.uniforms['sIntensity'].value = 0.0; // Lignes de scan (désactivé)
        filmPass.uniforms['grayscale'].value = 0;
        composer.addPass(filmPass);

        // --- GÉNÉRATEUR DE FORMES COMPLEXES ---
        function generateTargetTexture(shape) {
            const data = targetTexture.image.data;
            for (let k = 0, kl = data.length; k < kl; k += 4) {
                let x, y, z;
                const u = k / kl; // 0 à 1
                const idx = k/4;

                if(shape === "wave_plane") {
                    x = (Math.random()-0.5)*600;
                    z = (Math.random()-0.5)*300;
                    y = Math.sin(x*0.02 + z*0.01) * 50 + Math.sin(x*0.05)*20;
                } 
                else if(shape === "dna_helix") {
                    const turns = 8; const h = 500; const r = 60;
                    const angle = u * Math.PI * 2 * turns;
                    const strand = (idx % 2 === 0) ? 0 : Math.PI;
                    x = Math.cos(angle + strand) * r;
                    z = Math.sin(angle + strand) * r;
                    y = (u - 0.5) * h;
                }
                else if(shape === "lorenz") {
                    // Attracteur étrange (Maths du chaos)
                    let lx=1, ly=1, lz=1;
                    const dt = 0.005; const sigma=10, rho=28, beta=8/3;
                    // On itère un peu pour disperser
                    for(let j=0; j< (idx%100)+10; j++){
                        let dx = sigma * (ly - lx);
                        let dy = lx * (rho - lz) - ly;
                        let dz = lx * ly - beta * lz;
                        lx+=dx*dt; ly+=dy*dt; lz+=dz*dt;
                    }
                    x = lx*15; y = ly*15; z = lz*15 - 300;
                }
                else if(shape === "torus_knot") {
                    // Nœud toroïdal complexe
                    const t = u * Math.PI * 2 * 5; // 5 tours
                    const p=2, q=3; const r_tube=40; const R=150;
                    x = (R + r_tube * Math.cos(q*t)) * Math.cos(p*t);
                    z = (R + r_tube * Math.cos(q*t)) * Math.sin(p*t);
                    y = r_tube * Math.sin(q*t);
                }
                else { // Chaos sphere par défaut
                     const r = 250 * Math.cbrt(Math.random());
                     const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
                     x = r * Math.sin(phi) * Math.cos(theta); y = r * Math.sin(phi) * Math.sin(theta); z = r * Math.cos(phi);
                }
                data[k+0]=x; data[k+1]=y; data[k+2]=z; data[k+3]=1.0;
            }
            targetTexture.needsUpdate = true;
            positionUniforms["textureTarget"].value = targetTexture;
        }

        // --- NAVIGATION ---
        function next() {
            currentStep = (currentStep + 1) % story.length;
            const data = story[currentStep];

            // 1. Générer la nouvelle cible
            generateTargetTexture(data.shape);

            // 2. Animation des paramètres physiques GPGPU
            // Explosion puis attraction lente
            const tl = gsap.timeline();
            tl.to(positionUniforms["explosion"], { value: 1.0, duration: 0.5, ease:"power2.in" })
              .to(positionUniforms["explosion"], { value: 0.0, duration: 1.5, ease:"power3.out" })
              .to(positionUniforms["speed"], { value: 0.1, duration: 0, delay:-1.5 }) // Ralentir près de la cible
              .to(positionUniforms["speed"], { value: 0.8, duration: 2, delay:0 }); // Accélérer vers la nouvelle

            // 3. Couleurs HDR
            gsap.to(particleMaterial.uniforms.uColor.value, {
                r: data.color.r * 3.0, // Boost HDR pour le bloom
                g: data.color.g * 3.0,
                b: data.color.b * 3.0,
                duration: 3.0
            });

            // 4. UI Cinéma
            const chap = document.getElementById('chap-el');
            const txt = document.getElementById('text-el');
            chap.classList.remove('visible'); txt.classList.remove('visible');
            setTimeout(() => {
                chap.innerText = data.t; txt.innerHTML = data.s;
                chap.classList.add('visible'); txt.classList.add('visible');
            }, 1000);
        }

        // --- BOUCLE DE RENDU ---
        const clock = new THREE.Clock();
        let isRunning = false;

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            
            // 1. Calculer la physique GPGPU
            positionUniforms["time"].value = time;
            gpuCompute.compute();
            
            // 2. Mettre à jour le matériau visuel avec la nouvelle texture de positions
            particleMaterial.uniforms.texturePosition.value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;

            // 3. Mouvement Caméra "Drift"
            camera.position.x = Math.sin(time * 0.1) * 500 + Math.cos(time*0.15)*100;
            camera.position.z = Math.cos(time * 0.1) * 500;
            camera.position.y = Math.sin(time * 0.05) * 200;
            camera.lookAt(0,0,0);

            // 4. Rendu Post-Process
            composer.render();
        }

        // --- DÉMARRAGE ---
        document.getElementById('intro-screen').addEventListener('click', () => {
            document.getElementById('loading-text').innerText = "Lancement de la simulation...";
            // Init en différé pour laisser l'UI s'afficher
            setTimeout(() => {
                initGPGPU();
                initParticles();
                isRunning = true;
                animate();
                next(); // Chapitre 1

                gsap.to('#intro-screen', {opacity: 0, duration: 1.5, onComplete: () => document.getElementById('intro-screen').style.display = 'none'});
            }, 500);
        });

        window.addEventListener('click', () => { if(isRunning) next(); });
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            particleMaterial.uniforms.uRatio.value = renderer.getPixelRatio();
        });

    </script>
</body>
</html>
