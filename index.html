<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>L'Atelier - BLOCKBUSTER EDITION</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Montserrat:wght@300&display=swap');

        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: 'Montserrat', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* UI CINEMA */
        #ui-layer {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 40%; z-index: 10;
            background: linear-gradient(to top, #000 0%, transparent 100%);
            display: flex; flex-direction: column; justify-content: flex-end; align-items: center;
            padding-bottom: 50px; pointer-events: none;
        }

        .chapter {
            font-family: 'Cinzel', serif; color: #888; letter-spacing: 5px; font-size: 0.8rem;
            margin-bottom: 10px; text-transform: uppercase;
        }

        .text {
            font-family: 'Cinzel', serif; color: white; font-size: clamp(1.5rem, 5vw, 2.5rem);
            text-align: center; max-width: 90%; line-height: 1.4;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            opacity: 0; transform: translateY(20px); transition: all 1s ease;
        }
        .text.visible { opacity: 1; transform: translateY(0); }
        .highlight { color: #ffaa00; text-shadow: 0 0 30px #ffaa00; }

        /* ECRAN TITRE */
        #intro {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 50;
            background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 1s; cursor: pointer;
        }
        h1 {
            font-family: 'Cinzel', serif; font-size: clamp(2rem, 8vw, 4rem); color: white;
            text-align: center; text-shadow: 0 0 50px #00aaff;
        }
        .tap { margin-top: 20px; color: #666; font-size: 0.8rem; letter-spacing: 3px; text-transform: uppercase; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

    </style>
</head>
<body>

    <div id="intro">
        <h1>L'ATELIER<br>DES PARTICULES</h1>
        <div class="tap">Touchez pour démarrer</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="chapter-el" class="chapter"></div>
        <div id="text-el" class="text"></div>
        <div style="font-size: 0.6rem; color: #444; margin-top: 30px; text-transform: uppercase; letter-spacing: 2px;">
            Touchez l'écran pour la suite
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        // --- 1. CONFIGURATION "BLOCKBUSTER" ---
        // Moins de particules, mais BEAUCOUP plus grosses et visibles
        const PARTICLE_COUNT = 8000; 
        const PARTICLE_SIZE = 150.0; // Taille de base énorme (sera modulée par la profondeur)

        // --- 2. HISTOIRE ---
        const story = [
            {
                chapter: "I. LA MATIÈRE",
                text: "Une idée est une <span class='highlight'>étincelle</span> dans le noir.",
                shape: "chaos", // Explosion centrale
                color: new THREE.Color(1.0, 0.6, 0.1), // Or Feu
                speed: 1.0
            },
            {
                chapter: "II. L'ÉMOTION",
                text: "L'émotion est une <span class='highlight' style='color:#00aaff; text-shadow:0 0 30px #00aaff'>vague</span> qui nous emporte.",
                shape: "wave", // Nappe ondulante
                color: new THREE.Color(0.1, 0.4, 1.0), // Bleu Océan Électrique
                speed: 0.5
            },
            {
                chapter: "III. LA CONNEXION",
                text: "L'empathie tisse des <span class='highlight' style='color:#ff0055; text-shadow:0 0 30px #ff0055'>liens</span> invisibles.",
                shape: "dna", // Double hélice
                color: new THREE.Color(1.0, 0.1, 0.4), // Rouge Magenta
                speed: 0.8
            },
            {
                chapter: "IV. L'ŒUVRE",
                text: "Le chaos devient <span class='highlight' style='color:#00ff88; text-shadow:0 0 30px #00ff88'>structure</span>.",
                shape: "sphere", // Sphère parfaite
                color: new THREE.Color(0.2, 1.0, 0.6), // Vert Émeraude
                speed: 0.2
            },
            {
                chapter: "V. INFINI",
                text: "Tu es le créateur de cet univers.",
                shape: "galaxy", // Galaxie
                color: new THREE.Color(0.8, 0.5, 1.0), // Violet
                speed: 2.0
            }
        ];
        let currentStep = -1;

        // --- 3. TEXTURE GÉNÉRÉE (LE SECRET DE la VISIBILITÉ) ---
        function createSupernovaTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128; // Haute résolution
            const ctx = canvas.getContext('2d');
            
            // Dégradé Radial Puissant
            const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); // Cœur blanc pur
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)'); // Halo interne brillant
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)'); // Halo externe
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Transparent
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 128, 128);
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // --- 4. THREE.JS ENGINE ---
        const scene = new THREE.Scene();
        // Brouillard noir pour fondre les particules au loin
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.z = 150;

        const renderer = new THREE.WebGLRenderer({ powerPreference: "high-performance", antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Important pour que les couleurs "claquent"
        renderer.outputEncoding = THREE.sRGBEncoding; 
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- 5. SYSTÈME DE PARTICULES ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targets = new Float32Array(PARTICLE_COUNT * 3);
        const randoms = new Float32Array(PARTICLE_COUNT);

        // Initialisation (Big Bang au centre)
        for(let i=0; i<PARTICLE_COUNT; i++) {
            positions[i*3] = (Math.random()-0.5) * 10;
            positions[i*3+1] = (Math.random()-0.5) * 10;
            positions[i*3+2] = (Math.random()-0.5) * 10;
            randoms[i] = Math.random();
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('target', new THREE.BufferAttribute(targets, 3));
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));

        // SHADER PERSONNALISÉ "NEON"
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(1, 1, 1) },
                uTexture: { value: createSupernovaTexture() },
                uRatio: { value: renderer.getPixelRatio() }
            },
            vertexShader: `
                uniform float uTime;
                uniform float uRatio;
                attribute vec3 target;
                attribute float aRandom;
                varying float vAlpha;

                void main() {
                    vec3 pos = position; // Position interpolée par le JS

                    // Animation "VIVANTE" (Respiration complexe)
                    float movement = sin(uTime * 2.0 + aRandom * 20.0) * 2.0;
                    pos += normalize(pos) * movement;

                    // Orbite légère pour tout le monde
                    float angle = uTime * 0.1 * (aRandom - 0.5);
                    float ca = cos(angle); float sa = sin(angle);
                    // Rotation X
                    // pos.yz = mat2(ca, -sa, sa, ca) * pos.yz; 

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_Position = projectionMatrix * mvPosition;

                    // TAILLE DYNAMIQUE (LE POINT CLÉ)
                    // Plus c'est proche, plus c'est énorme
                    // aRandom fait varier la taille pour donner de la profondeur
                    float size = ${PARTICLE_SIZE.toFixed(1)} * (0.5 + aRandom);
                    gl_PointSize = (size * uRatio) / -mvPosition.z;

                    // Visibilité distance
                    vAlpha = smoothstep(500.0, 300.0, -mvPosition.z);
                }
            `,
            fragmentShader: `
                uniform vec3 uColor;
                uniform sampler2D uTexture;
                varying float vAlpha;

                void main() {
                    vec4 tex = texture2D(uTexture, gl_PointCoord);
                    
                    // Si le pixel est noir dans la texture, on ne le dessine pas (perf)
                    if (tex.a < 0.05) discard;

                    // Couleur intense + transparence de la texture
                    gl_FragColor = vec4(uColor, tex.a * vAlpha);
                }
            `,
            transparent: true,
            depthWrite: false,
            // ADDITIVE BLENDING : C'est ça qui fait l'effet "Lumière/Laser"
            blending: THREE.AdditiveBlending 
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 6. CALCUL DES FORMES (MATHS) ---
        function setShape(shapeName) {
            const targetAttr = geometry.attributes.target;
            
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const u = i / PARTICLE_COUNT; // 0 à 1
                let x, y, z;

                if (shapeName === 'chaos') {
                    // Explosion Sphérique
                    const r = 150 * Math.cbrt(Math.random()); // Distribution uniforme dans sphère
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                } 
                else if (shapeName === 'wave') {
                    // Vague Océanique
                    x = (u - 0.5) * 400;
                    z = (Math.random() - 0.5) * 150;
                    // Onde sinusoïdale complexe
                    y = Math.sin(x * 0.02) * 30 + Math.sin(z * 0.05) * 20;
                }
                else if (shapeName === 'dna') {
                    // Double Hélice géante
                    const turns = 10;
                    const angle = u * Math.PI * 2 * turns;
                    const radius = 30;
                    const height = 300;
                    
                    // On sépare en deux brins
                    const strandOffset = (i % 2 === 0) ? 0 : Math.PI;
                    
                    x = Math.cos(angle + strandOffset) * radius;
                    z = Math.sin(angle + strandOffset) * radius;
                    y = (u - 0.5) * height;
                    
                    // Ajout de bruit pour faire "organique"
                    x += (Math.random()-0.5) * 5;
                    z += (Math.random()-0.5) * 5;
                }
                else if (shapeName === 'sphere') {
                    // Sphère creuse (Cristal)
                    const radius = 80;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    x = radius * Math.sin(phi) * Math.cos(theta);
                    y = radius * Math.sin(phi) * Math.sin(theta);
                    z = radius * Math.cos(phi);
                    
                    // Structure géométrique (lignes)
                    if (Math.random() > 0.8) {
                        x *= 1.2; y *= 1.2; z *= 1.2; // Aura externe
                    }
                }
                else if (shapeName === 'galaxy') {
                    // Spirale Galactique
                    const arms = 3;
                    const armIndex = i % arms;
                    const armOffset = (Math.PI * 2 / arms) * armIndex;
                    const distance = Math.random(); // 0 centre, 1 bord
                    const spiralAngle = distance * 10;
                    
                    const r = distance * 200;
                    x = Math.cos(spiralAngle + armOffset) * r;
                    z = Math.sin(spiralAngle + armOffset) * r;
                    y = (Math.random() - 0.5) * (20 * (1-distance)); // Plus plat au bord
                }

                targetAttr.setXYZ(i, x, y, z);
            }
            targetAttr.needsUpdate = true;
        }

        // --- 7. NAVIGATION ---
        function nextSlide() {
            currentStep++;
            if (currentStep >= story.length) currentStep = 0; // Boucle

            const data = story[currentStep];

            // 1. Calculer la forme
            setShape(data.shape);

            // 2. Changer la couleur
            gsap.to(material.uniforms.uColor.value, {
                r: data.color.r, g: data.color.g, b: data.color.b,
                duration: 2.0
            });

            // 3. Texte UI
            const chapEl = document.getElementById('chapter-el');
            const txtEl = document.getElementById('text-el');
            
            // Fade out
            txtEl.classList.remove('visible');
            
            setTimeout(() => {
                chapEl.innerText = data.chapter;
                txtEl.innerHTML = data.text;
                txtEl.classList.add('visible');
            }, 500);
        }

        // --- 8. BOUCLE D'ANIMATION (Le Cœur) ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            material.uniforms.uTime.value = time;

            // MORPHING FLUIDE (Interpolation linéaire)
            // On déplace chaque particule vers sa cible petit à petit
            const positions = geometry.attributes.position;
            const targets = geometry.attributes.target;
            // Vitesse de transition
            const speed = 2.0 * dt; 

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const ix = i*3;
                const iy = i*3+1;
                const iz = i*3+2;

                positions.array[ix] += (targets.array[ix] - positions.array[ix]) * speed;
                positions.array[iy] += (targets.array[iy] - positions.array[iy]) * speed;
                positions.array[iz] += (targets.array[iz] - positions.array[iz]) * speed;
            }
            positions.needsUpdate = true;

            // Rotation Caméra (Cinématique)
            // Rotation lente autour du centre
            const camSpeed = 0.1;
            camera.position.x = Math.sin(time * camSpeed) * 150;
            camera.position.z = Math.cos(time * camSpeed) * 150;
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        // --- 9. INTERACTION ---
        const introDiv = document.getElementById('intro');
        
        // Clic n'importe où
        document.body.addEventListener('click', () => {
            if (introDiv.style.opacity !== '0') {
                // Premier clic : Démarrer
                introDiv.style.opacity = '0';
                setTimeout(() => introDiv.style.display = 'none', 1000);
                nextSlide();
                animate();
            } else {
                // Clics suivants : Changer de scène
                nextSlide();
            }
        });

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.uRatio.value = renderer.getPixelRatio();
        });

    </script>
</body>
</html>
