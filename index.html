<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>L'Odyssée Créative - Mobile Experience</title>
    <style>
        /* TYPOGRAPHIE IMMERSIVE */
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@300;600&family=Playfair+Display:ital,wght@1,400;1,600&display=swap');

        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: 'Montserrat', sans-serif; 
            -webkit-tap-highlight-color: transparent;
        }

        /* CONTENEUR UI */
        #ui-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none; /* Laisse passer les clics vers le canvas */
            display: flex; flex-direction: column; justify-content: flex-end; align-items: center;
            padding-bottom: 8vh;
            background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, transparent 40%);
        }

        /* TITRE CHAPITRE */
        .chapter-tag {
            font-size: 0.7rem; letter-spacing: 4px; text-transform: uppercase; 
            color: rgba(255,255,255,0.5); margin-bottom: 20px; border: 1px solid rgba(255,255,255,0.2);
            padding: 5px 15px; border-radius: 20px; opacity: 0; transform: translateY(10px);
            transition: all 1s ease;
        }

        /* TEXTE NARRATIF */
        .story-text {
            font-family: 'Playfair Display', serif; font-size: clamp(1.4rem, 5vw, 2.2rem);
            font-style: italic; text-align: center; color: #fff; line-height: 1.4;
            max-width: 90%; padding: 0 20px; margin-bottom: 30px;
            text-shadow: 0 4px 20px black;
            opacity: 0; transform: translateY(20px); filter: blur(5px);
            transition: all 1.2s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        .story-text span { color: #ffcc00; } /* Highlight */

        /* CLASSES D'ANIMATION */
        .active { opacity: 1 !important; transform: translateY(0) !important; filter: blur(0) !important; }

        /* ÉCRAN DE DÉPART */
        #intro {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 50;
            background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 1.5s; cursor: pointer; pointer-events: auto;
        }
        h1 {
            font-family: 'Playfair Display', serif; font-size: 2.5rem; color: white; margin-bottom: 10px;
            text-align: center; letter-spacing: 2px;
        }
        .tap-hint {
            font-size: 0.8rem; letter-spacing: 3px; text-transform: uppercase; color: #888;
            animation: pulse 2s infinite; margin-top: 20px;
        }
        @keyframes pulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }

        /* PROGRESS BAR */
        #progress-bar {
            position: absolute; top: 0; left: 0; height: 4px; background: #ffcc00;
            width: 0%; transition: width 1s linear; z-index: 20; box-shadow: 0 0 10px #ffcc00;
        }

        #canvas-webgl { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
    </style>
</head>
<body>

    <div id="intro">
        <h1>L'Atelier des<br>Particules</h1>
        <div class="tap-hint">Touchez l'écran pour commencer</div>
    </div>

    <div id="progress-bar"></div>
    <div id="canvas-webgl"></div>

    <div id="ui-container">
        <div id="ui-chapter" class="chapter-tag">INTRODUCTION</div>
        <div id="ui-text" class="story-text"></div>
        <div style="font-size: 0.7rem; color: #555; margin-top: 20px;">Touchez pour continuer</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        // --- 1. HISTOIRE & SCÉNARIO DÉTAILLÉ ---
        const story = [
            {
                // INTRO
                chapter: "L'ORIGINE",
                text: "La créativité n'est pas une magie.<br>C'est une <span>danse</span> entre des forces invisibles.",
                mode: "cloud", // Nuage calme
                color: { r: 1.0, g: 1.0, b: 1.0 }, // Blanc
                storm: 0.0
            },
            {
                // MOUVEMENT 1 : IDÉES (ORAGE)
                chapter: "I. LA MATIÈRE",
                text: "Tout commence par les <span>Idées</span>.<br>Des étincelles chaotiques qui surgissent du néant.",
                mode: "chaos", 
                color: { r: 1.0, g: 0.9, b: 0.5 }, // Or pâle
                storm: 0.5 // Début agitation
            },
            {
                chapter: "I. LA MATIÈRE",
                text: "C'est un <span>orage mental</span>.<br>Des micro-éclairs qui cherchent leur chemin dans l'obscurité.",
                mode: "chaos",
                color: { r: 1.0, g: 0.8, b: 0.2 }, // Or intense
                storm: 1.0 // ORAGE TOTAL (Vibration forte)
            },
            {
                // MOUVEMENT 2 : ÉMOTIONS (FLUIDE)
                chapter: "II. LE FLUX",
                text: "Puis, l'<span>Émotion</span> entre en scène.<br>Elle calme la tempête et crée des courants profonds.",
                mode: "wave", // Vagues douces
                color: { r: 0.2, g: 0.5, b: 1.0 }, // Bleu océan
                storm: 0.0
            },
            {
                chapter: "II. LE FLUX",
                text: "L'idée ne suffit pas.<br>Elle doit être portée par un sentiment pour devenir vivante.",
                mode: "wave",
                color: { r: 0.1, g: 0.8, b: 0.9 }, // Cyan
                storm: 0.0
            },
            {
                // MOUVEMENT 3 : EMPATHIE (CONNEXION)
                chapter: "III. LA CONNEXION",
                text: "Voici l'<span>Empathie</span>.<br>C'est le réseau invisible qui nous relie aux autres.",
                mode: "network", // Forme de réseau / Plexus
                color: { r: 1.0, g: 0.4, b: 0.7 }, // Rose Magenta
                storm: 0.0
            },
            {
                chapter: "III. LA CONNEXION",
                text: "Regardez les liens se tisser.<br>L'idée isolée devient une histoire partagée.",
                mode: "network",
                color: { r: 1.0, g: 0.2, b: 0.5 }, // Rose vif
                storm: 0.0
            },
            {
                // MOUVEMENT 4 : CRISTALLISATION (DIAMANT)
                chapter: "IV. L'ŒUVRE",
                text: "Soudain, le mouvement se fige.<br>C'est la <span>Cristallisation</span>.",
                mode: "crystal", // Forme géométrique stable
                color: { r: 0.5, g: 1.0, b: 0.5 }, // Vert émeraude / Blanc
                storm: 0.0
            },
            {
                chapter: "IV. L'ŒUVRE",
                text: "Le chaos a trouvé sa forme.<br>Une structure parfaite, solide, utile.",
                mode: "crystal",
                color: { r: 1.0, g: 1.0, b: 1.0 }, // Diamant blanc
                storm: 0.0
            },
            {
                // FIN : GALAXIE
                chapter: "HABITER LE MONDE",
                text: "Tu n'es pas spectateur.<br>Tu es le <span>centre</span> de cet univers créatif.",
                mode: "galaxy", // Spirale
                color: { r: 0.6, g: 0.4, b: 1.0 }, // Violet cosmique
                storm: 0.0
            },
            {
                chapter: "FIN",
                text: "L'Atelier est ouvert.<br>À toi de créer.",
                mode: "galaxy",
                color: { r: 1.0, g: 1.0, b: 1.0 },
                storm: 0.2
            }
        ];

        let currentStep = -1;

        // --- 2. MOTEUR GRAPHIQUE (THREE.JS) ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.015); // Brouillard pour la profondeur

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // Ajustement caméra pour mobile (plus loin si écran étroit)
        function adjustCamera() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.position.z = aspect < 1 ? 140 : 100;
        }
        adjustCamera();

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Optimisation iPhone : On limite le pixel ratio pour éviter la surchauffe
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        document.getElementById('canvas-webgl').appendChild(renderer.domElement);

        // --- 3. CRÉATION DE LA TEXTURE (Halo Lumineux) ---
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
            // Cœur blanc solide + Halo dégradé
            gradient.addColorStop(0, 'rgba(255,255,255,1)'); 
            gradient.addColorStop(0.3, 'rgba(255,255,255,0.4)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 64, 64);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // --- 4. SYSTÈME DE PARTICULES (MORPHING) ---
        const particleCount = 15000; // Optimisé pour iPhone
        const geometry = new THREE.BufferGeometry();
        
        const positions = new Float32Array(particleCount * 3);
        const targets = new Float32Array(particleCount * 3); // Position cible
        const randoms = new Float32Array(particleCount); // Pour animer différemment chaque point

        // Init : Nuage aléatoire
        for(let i=0; i<particleCount; i++) {
            positions[i*3] = (Math.random()-0.5)*300;
            positions[i*3+1] = (Math.random()-0.5)*300;
            positions[i*3+2] = (Math.random()-0.5)*300;
            randoms[i] = Math.random();
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('target', new THREE.BufferAttribute(targets, 3));
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));

        // --- LE SHADER (Cerveau Visuel) ---
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(1, 1, 1) },
                uStorm: { value: 0.0 }, // Intensité de l'orage
                uTexture: { value: createGlowTexture() },
                uRatio: { value: renderer.getPixelRatio() }
            },
            vertexShader: `
                uniform float uTime;
                uniform float uStorm;
                uniform float uRatio;
                attribute vec3 target;
                attribute float aRandom;
                varying float vAlpha;

                // Fonction de bruit simple
                float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123); }

                void main() {
                    vec3 pos = position; // Position interpolée par le JS (Morphing)

                    // 1. ANIMATION ORAGE (Chaos vibrant)
                    if (uStorm > 0.1) {
                        // Secousse rapide et aléatoire
                        float shake = sin(uTime * 20.0 + aRandom * 100.0) * uStorm * 2.0;
                        pos += normalize(pos) * shake;
                    }

                    // 2. ANIMATION DOUCE (Respiration)
                    float breathe = sin(uTime * 1.5 + aRandom * 10.0) * 0.5;
                    pos.y += breathe;

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_Position = projectionMatrix * mvPosition;

                    // 3. TAILLE DYNAMIQUE
                    // Les particules scintillent pendant l'orage
                    float flicker = 1.0;
                    if(uStorm > 0.5) flicker = 0.5 + random(vec2(uTime, aRandom));

                    // Taille adaptée à l'écran (Responsive)
                    // Plus gros sur mobile pour être visible
                    float baseSize = 40.0 * (1.0 + aRandom); 
                    gl_PointSize = (baseSize * uRatio * flicker) / -mvPosition.z;

                    // 4. OPACITÉ (Fade out au loin)
                    vAlpha = smoothstep(200.0, 10.0, -mvPosition.z);
                }
            `,
            fragmentShader: `
                uniform vec3 uColor;
                uniform float uStorm;
                uniform sampler2D uTexture;
                varying float vAlpha;

                void main() {
                    vec4 tex = texture2D(uTexture, gl_PointCoord);
                    
                    // Couleur finale : mélange couleur de base + blanc pendant l'orage (éclairs)
                    vec3 finalColor = mix(uColor, vec3(1.0), uStorm * 0.5);
                    
                    gl_FragColor = vec4(finalColor, tex.a * vAlpha);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending // Mélange additif pour l'effet lumineux
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 5. GÉNÉRATEURS DE FORMES (Maths) ---
        function calculateShape(mode) {
            const tArray = geometry.attributes.target.array;
            
            for(let i=0; i<particleCount; i++) {
                let x, y, z;
                // Index normalisé (0 à 1)
                const u = i / particleCount; 

                if (mode === 'cloud') {
                    x = (Math.random()-0.5)*200;
                    y = (Math.random()-0.5)*100;
                    z = (Math.random()-0.5)*100;
                }
                else if (mode === 'chaos') {
                    // Sphère éclatée
                    const r = 100 * Math.random();
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }
                else if (mode === 'wave') {
                    // Nappe ondulante
                    x = (u - 0.5) * 200;
                    z = (Math.random() - 0.5) * 80;
                    y = Math.sin(x * 0.05) * 20 + Math.cos(z * 0.1) * 10;
                }
                else if (mode === 'network') {
                    // Simulation de connexions (Lignes qui partent d'un centre)
                    // On crée plusieurs "noeuds"
                    const branches = 10;
                    const branch = Math.floor(u * branches);
                    const t = (u * branches) - branch; // 0 à 1 le long de la branche
                    const angle = (branch / branches) * Math.PI * 2;
                    const r = t * 80;
                    // Spirale légère
                    x = Math.cos(angle + t) * r;
                    y = (Math.random()-0.5) * 10 + t * 20;
                    z = Math.sin(angle + t) * r;
                }
                else if (mode === 'crystal') {
                    // Octaèdre (Diamant)
                    const size = 40;
                    x = (Math.random()-0.5)*size*2;
                    y = (Math.random()-0.5)*size*2;
                    z = (Math.random()-0.5)*size*2;
                    // On projette sur les faces
                    if(Math.abs(x)+Math.abs(y)+Math.abs(z) > size) {
                        const s = size / (Math.abs(x)+Math.abs(y)+Math.abs(z));
                        x*=s; y*=s; z*=s;
                    }
                }
                else if (mode === 'galaxy') {
                    // Spirale
                    const angle = u * Math.PI * 10; // 5 tours
                    const r = u * 100;
                    x = Math.cos(angle) * r;
                    z = Math.sin(angle) * r;
                    y = (Math.random()-0.5) * (20 - u*10); // Plus plat au bord
                }

                tArray[i*3] = x;
                tArray[i*3+1] = y;
                tArray[i*3+2] = z;
            }
            geometry.attributes.target.needsUpdate = true;
        }

        // --- 6. NAVIGATION & TRANSITIONS ---
        function nextStep() {
            currentStep++;
            if (currentStep >= story.length) currentStep = 0; // Boucle

            const data = story[currentStep];

            // 1. Mise à jour Barre Progression
            document.getElementById('progress-bar').style.width = ((currentStep+1) / story.length * 100) + "%";

            // 2. Calculer la nouvelle forme
            calculateShape(data.mode);

            // 3. Animation des valeurs (Couleur, Orage)
            gsap.to(material.uniforms.uColor.value, {
                r: data.color.r, g: data.color.g, b: data.color.b,
                duration: 2
            });
            gsap.to(material.uniforms.uStorm, {
                value: data.storm,
                duration: 1
            });

            // 4. Animation UI (Texte)
            const tag = document.getElementById('ui-chapter');
            const txt = document.getElementById('ui-text');
            
            // Fade out
            tag.classList.remove('active');
            txt.classList.remove('active');

            setTimeout(() => {
                tag.innerText = data.chapter;
                txt.innerHTML = data.text;
                // Fade in
                tag.classList.add('active');
                txt.classList.add('active');
            }, 800);
        }

        // Démarrage au clic
        const intro = document.getElementById('intro');
        // On écoute le clic sur TOUT le document pour avancer
        document.body.addEventListener('click', (e) => {
            // Si c'est l'intro
            if (intro.style.opacity !== '0') {
                intro.style.opacity = '0';
                setTimeout(() => intro.style.display = 'none', 1500);
                nextStep(); // Lancer le premier chapitre
            } else {
                // Sinon passer à la suite
                nextStep();
            }
        });

        // --- 7. BOUCLE D'ANIMATION OPTIMISÉE ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            material.uniforms.uTime.value = time;

            // MORPHING (Interpolation des positions)
            // On déplace les points vers leur cible progressivement
            const posAttr = geometry.attributes.position;
            const targetAttr = geometry.attributes.target;
            const speed = 2.5 * dt; // Vitesse de transition

            for(let i=0; i<particleCount; i++) {
                const ix = i*3;
                const iy = ix+1;
                const iz = ix+2;
                
                posAttr.array[ix] += (targetAttr.array[ix] - posAttr.array[ix]) * speed;
                posAttr.array[iy] += (targetAttr.array[iy] - posAttr.array[iy]) * speed;
                posAttr.array[iz] += (targetAttr.array[iz] - posAttr.array[iz]) * speed;
            }
            posAttr.needsUpdate = true;

            // Rotation caméra lente (Cinématique)
            const camSpeed = (story[currentStep] && story[currentStep].storm > 0.1) ? 0.3 : 0.05; // Plus vite si orage
            
            camera.position.x = Math.sin(time * camSpeed) * 20;
            camera.position.y = Math.cos(time * camSpeed * 0.5) * 10;
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.uRatio.value = renderer.getPixelRatio();
            adjustCamera();
        });

        animate();

    </script>
</body>
</html>
